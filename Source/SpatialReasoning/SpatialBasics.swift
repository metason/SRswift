//
//  SpatialBasics.swift
//  SpatialReasoning
//
//  Created by Philipp Ackermann on 25.11.2024.
//

import Foundation

// Calculation schema to determine sector size for extruding area
public enum SectorSchema {
    case fixed // use specified fix lenght for extruding area
    case dimension // use same dimension as object multiplied with factor
    case perimeter // use area perimeter multiplied with factor
    case area // use area multiplied with factor
    case nearby // use nearby settings for extruding
    case wide // use fix wide
}

// Default adjustment only used when no SpatialReasoner builds context
nonisolated(unsafe) var defaultAdjustment = SpatialAdjustment()

// Set adjustment parameters before executing pipeline or calling relate() method.
// SpatialReasoner has its own local adjustment that should be set upfront.
class SpatialAdjustment {
    // Max deviations
    var gap:Float = 0.02 /// gap ist max distance of deviation in all directions in meters
    var angle:Float = 0.05 * .pi /// angle is max delta of yaw orientation in radiants in both directions
    // Sector size
    var sectorSchema:SectorSchema = .wide
    var sectorFactor:Float = 1.0 /// sectorFactor is multiplying the result of claculation schema
    var sectorLimit:Float = 2.5 /// sectorLimit is maximal length
    var fixSectorLenght:Float = 0.25
    var wideSectorLenght:Float = 10.0
    // Vicinity
    var nearbyFactor:Float = 1.0 /// nearbyFactor is multiplying radius sum of object and subject (relative to size) as max distance
    var nearbyLimit:Float = 2.0 /// nearbyLimit is maximal absolute distance
    // Proportions
    var longRatio:Float = 4.0 /// one dimension is factor larger than both others
    var thinRatio:Float = 10.0 /// one dimension is 1/factor smaller than both others
    
    /// get/set max delta of orientation in degrees
    var yaw:Float {
        return angle * 180.0 / .pi
    }
    func setYaw(_ degrees:Float) {
        angle = degrees * .pi / 180.0
    }
}

class SpatialPredicateCategories {
    var topology = true
    var connectivity = true
    var comparability = false
    var directionality = false
    var visibility = true
    var geography = false
}

class ObjectConfidence { // plausability values between 0.0 and 1.0
    var pose:Float = 0.0 // plausability of position and orientation of (partially) detected part
    var dimension:Float = 0.0  // plausability of size of spatial object
    var label:Float = 0.0  // plausability of classification: label, type, supertype
    var look:Float = 0.0  // plausability of look and shape
    var value:Float {
        return (pose + dimension + label)/3.0
    }
    func setValue(_ value:Float) {
        pose = value
        dimension = value
        label = value
    }
    var spatial:Float {
        return (pose + dimension)/2.0
    }
    func setSpatial(_ value:Float) {
        pose = value
        dimension = value
    }
    func asDict() -> Dictionary<String, Float> {
        return ["pose":pose, "dimension":dimension, "label":label, "look":look]  
    }
}

// Searchable, metric, spatio-temporal attributes
public enum SpatialAtribute: String {
    case none
    case width
    case height
    case depth
    case footprint // base surface
    case frontface // front surface
    case sideface // side surface
    case volume
    case perimeter
    case groundradius // radius of 2D floorground circle
    case radius // radius of sphere including 3D bbox around center
    case lifespan
}

public enum SpatialExistence: String {
    case real // visual, detected, real object
    case virtual // visual, created, virtual object
    case conceptual // non-visual, conceptual area, e.g., corner, zone, sensing area, region of interest, interaction field
    case aggregational // non-visual part-of group, container
}

public enum ObjectCause : String {
    case unknown
    case plane_detected // on-device plane detection
    case object_detected // on-device object detection
    case self_tracked // device of user registered and tracked in space
    case user_captured // captured by user
    case user_generated // generated by user
    case logic_induced // instanciated by rule or by program logic
    case remote_produced // produced by remote service
}

public enum MotionState: String {
    case unknown
    case stationary // immobile
    case idle // idle
    case moving // moving
}

public enum ObjectShape : String {
    case unknown
    case planar // plane, thin box
    case cubical // box
    case spherical
    case cylindrical // along longest dimension when long
    case conical
    case irregular // complex shape
    case changing // changing shape, e.g., of creature
}

// TODO: operable?
public enum ObjectHandling : String {
    case none
    case movable
    case slidable
    case liftable
    case portable
    case rotatable
    case openable
    //case tangible // ?? user-dep.
}

