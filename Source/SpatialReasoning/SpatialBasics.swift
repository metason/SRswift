//
//  SpatialBasics.swift
//  SpatialReasoning
//
//  Created by Philipp Ackermann on 25.11.2024.
//

import Foundation

nonisolated(unsafe) var defaultAdjustment = SpatialAdjustment()

// Set adjustment parameters before executing pipeline or calling relate() method
class SpatialAdjustment {
    // Max deviations
    var gap:Float = 0.05 /// gap ist max distance of deviation in all directions in meters
    var angle:Float = 0.05 * .pi /// angle is max delta of yaw orientation in radiants in both directions
    // Vicinity
    var nearbyLimit:Float = 1.5 /// nearbyLimit is maximal absolute distance
    var nearbyFactor:Float = 1.0 /// nearbyFactor is multiplying radius sum of object and subject (relative to size) as max distance
    /// minimal ratio of max : min bbox sides to be thin
    // Proportions
    var longRatio:Float = 4.0 /// one dimension is factor larger than both others
    var thinRatio:Float = 10.0 /// one dimension is 1/factor smaller than both others

    
    /// get/set max delta of orientation in degrees
    var yaw:Float {
        return angle * 180.0 / .pi
    }
    func setYaw(_ degrees:Float) {
        angle = degrees * .pi / 180.0
    }
}

class ObjectConfidence { // plausability values between 0.0 and 1.0
    var pose:Float = 0.0 // plausability of position and orientation of (partially) detected part
    var dimension:Float = 0.0  // plausability of size of spatial object
    var label:Float = 0.0  // plausability of classification: label, type, supertype
    var look:Float = 0.0  // plausability of look and shape
    var value:Float {
        return (pose + dimension + label)/3.0
    }
    func setValue(_ value:Float) {
        pose = value
        dimension = value
        label = value
    }
    var spatial:Float {
        return (pose + dimension)/2.0
    }
    func setSpatial(_ value:Float) {
        pose = value
        dimension = value
    }
    func asDict() -> Dictionary<String, Float> {
        return ["pose":pose, "dimension":dimension, "label":label, "look":look]  
    }
}

// Searchable, metric, spatio-temporal attributes
public enum SpatialAtribute: String {
    case none
    case width
    case height
    case depth
    case footprint // base surface
    case frontface // front surface
    case sideface // side surface
    case volume
    case perimeter
    case groundradius // radius of 2D floorground circle
    case radius // radius of sphere including 3D bbox around center
    case lifespan
}

public enum SpatialExistence: String {
    case real // visual, detected, real object
    case virtual // visual, created, virtual object
    case conceptual // non-visual, conceptual area, e.g., corner, zone, sensing area, region of interest, interaction field
}

public enum ObjectCause : String {
    case unknown
    case planedetected // on-device plane detection
    case objectdetected // on-device object detection
    case selftracked // device of user registered and tracked in space
    case usercaptured // captured by user
    case usergenerated // generated by user
    case logicinduced // instanciated by rule or by program logic
    case remoteproduced // produced by remote service
}

public enum MotionState: String {
    case unknown
    case stationary // immobile
    case idle // idle
    case moving // moving
}

public enum ObjectShape : String {
    case unknown
    case planar // plane, thin box
    case cubical // box
    case spherical
    case cylindrical // along longest dimension when long
    case conical
    case irregular // complex shape
    case changing // changing shape, e.g., of creature
}

// TODO: operable?
public enum ObjectHandling : String {
    case none
    case movable
    case slidable
    case liftable
    case portable
    case rotatable
    case openable
    //case tangible // ?? user-dep.
}

